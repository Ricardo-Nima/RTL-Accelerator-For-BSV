//
// Generated by Bluespec Compiler, version 2022.01 (build 066c7a8)
//
// On Tue Dec 27 17:20:18 CST 2022
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTb(CLK,
	    RST_N);
  input  CLK;
  input  RST_N;

  // inlined wires
  wire start_wire$whas, state_overlap_pw$whas, state_set_pw$whas;

  // register jj_1_repeat_count
  reg [1 : 0] jj_1_repeat_count;
  wire [1 : 0] jj_1_repeat_count$D_IN;
  wire jj_1_repeat_count$EN;

  // register jj_repeat_count
  reg [1 : 0] jj_repeat_count;
  wire [1 : 0] jj_repeat_count$D_IN;
  wire jj_repeat_count$EN;

  // register running
  reg running;
  wire running$D_IN, running$EN;

  // register start_reg
  reg start_reg;
  wire start_reg$D_IN, start_reg$EN;

  // register start_reg_1
  reg start_reg_1;
  wire start_reg_1$D_IN, start_reg_1$EN;

  // register state_can_overlap
  reg state_can_overlap;
  wire state_can_overlap$D_IN, state_can_overlap$EN;

  // register state_fired
  reg state_fired;
  wire state_fired$D_IN, state_fired$EN;

  // register state_mkFSMstate
  reg [4 : 0] state_mkFSMstate;
  reg [4 : 0] state_mkFSMstate$D_IN;
  wire state_mkFSMstate$EN;

  // ports of submodule spiflash_ctrl
  reg [8 : 0] spiflash_ctrl$operate_addr;
  reg [7 : 0] spiflash_ctrl$operate_data;
  wire [7 : 0] spiflash_ctrl$read_byte;
  wire spiflash_ctrl$EN_operate,
       spiflash_ctrl$EN_read_byte,
       spiflash_ctrl$RDY_operate,
       spiflash_ctrl$RDY_read_byte,
       spiflash_ctrl$miso_i_i,
       spiflash_ctrl$operate_wr;

  // rule scheduling signals
  wire WILL_FIRE_RL_action_l21c22,
       WILL_FIRE_RL_action_l22c22,
       WILL_FIRE_RL_action_l24c22,
       WILL_FIRE_RL_action_l25c22,
       WILL_FIRE_RL_action_l26c22,
       WILL_FIRE_RL_action_l28c22,
       WILL_FIRE_RL_action_l30c22,
       WILL_FIRE_RL_action_l31c22,
       WILL_FIRE_RL_action_l32c32,
       WILL_FIRE_RL_action_l34c22,
       WILL_FIRE_RL_action_l36c22,
       WILL_FIRE_RL_action_l37c22,
       WILL_FIRE_RL_action_l38c32,
       WILL_FIRE_RL_action_ovlp_r_update_l32c9,
       WILL_FIRE_RL_action_ovlp_r_update_l38c9,
       WILL_FIRE_RL_action_r_init_l32c9,
       WILL_FIRE_RL_action_r_init_l38c9,
       WILL_FIRE_RL_fsm_start,
       WILL_FIRE_RL_idle_l20c16;

  // inputs to muxes for submodule ports
  wire [1 : 0] MUX_jj_1_repeat_count$write_1__VAL_1,
	       MUX_jj_repeat_count$write_1__VAL_1;
  wire MUX_spiflash_ctrl$operate_1__SEL_1,
       MUX_spiflash_ctrl$operate_1__SEL_2,
       MUX_start_reg$write_1__SEL_2;

  // remaining internal signals
  wire [1 : 0] x__h53196, x__h53386;
  wire NOT_jj_1_repeat_count_read__8_BIT_0_9_6_AND_NO_ETC___d106,
       NOT_jj_repeat_count_read__7_BIT_0_8_9_AND_NOT__ETC___d83,
       abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d123,
       abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d130,
       jj_1_repeat_count_read__8_BIT_0_9_AND_NOT_abor_ETC___d103,
       jj_repeat_count_read__7_BIT_0_8_AND_NOT_abort__ETC___d78;

  // submodule spiflash_ctrl
  mkSPIFlashController spiflash_ctrl(.CLK(CLK),
				     .RST_N(RST_N),
				     .miso_i_i(spiflash_ctrl$miso_i_i),
				     .operate_addr(spiflash_ctrl$operate_addr),
				     .operate_data(spiflash_ctrl$operate_data),
				     .operate_wr(spiflash_ctrl$operate_wr),
				     .EN_operate(spiflash_ctrl$EN_operate),
				     .EN_read_byte(spiflash_ctrl$EN_read_byte),
				     .RDY_operate(spiflash_ctrl$RDY_operate),
				     .read_byte(spiflash_ctrl$read_byte),
				     .RDY_read_byte(spiflash_ctrl$RDY_read_byte),
				     .ss_o(),
				     .sck_o(),
				     .mosi_o());

  // rule RL_action_l22c22
  assign WILL_FIRE_RL_action_l22c22 =
	     spiflash_ctrl$RDY_operate && state_mkFSMstate == 5'd1 ;

  // rule RL_action_l24c22
  assign WILL_FIRE_RL_action_l24c22 =
	     spiflash_ctrl$RDY_operate && state_mkFSMstate == 5'd2 ;

  // rule RL_action_l25c22
  assign WILL_FIRE_RL_action_l25c22 =
	     spiflash_ctrl$RDY_operate && state_mkFSMstate == 5'd3 ;

  // rule RL_action_l26c22
  assign WILL_FIRE_RL_action_l26c22 =
	     spiflash_ctrl$RDY_operate && state_mkFSMstate == 5'd4 ;

  // rule RL_action_l28c22
  assign WILL_FIRE_RL_action_l28c22 =
	     spiflash_ctrl$RDY_operate && state_mkFSMstate == 5'd5 ;

  // rule RL_action_l30c22
  assign WILL_FIRE_RL_action_l30c22 =
	     spiflash_ctrl$RDY_operate && state_mkFSMstate == 5'd6 ;

  // rule RL_action_l31c22
  assign WILL_FIRE_RL_action_l31c22 =
	     spiflash_ctrl$RDY_operate && state_mkFSMstate == 5'd7 ;

  // rule RL_action_r_init_l32c9
  assign WILL_FIRE_RL_action_r_init_l32c9 =
	     !jj_repeat_count[0] && state_mkFSMstate == 5'd8 ;

  // rule RL_action_l34c22
  assign WILL_FIRE_RL_action_l34c22 =
	     spiflash_ctrl$RDY_operate && jj_repeat_count[0] &&
	     state_mkFSMstate == 5'd11 ;

  // rule RL_action_l36c22
  assign WILL_FIRE_RL_action_l36c22 =
	     spiflash_ctrl$RDY_operate && state_mkFSMstate == 5'd13 ;

  // rule RL_action_l37c22
  assign WILL_FIRE_RL_action_l37c22 =
	     spiflash_ctrl$RDY_operate && state_mkFSMstate == 5'd14 ;

  // rule RL_action_r_init_l38c9
  assign WILL_FIRE_RL_action_r_init_l38c9 =
	     !jj_1_repeat_count[0] && state_mkFSMstate == 5'd15 ;

  // rule RL_action_ovlp_r_update_l32c9
  assign WILL_FIRE_RL_action_ovlp_r_update_l32c9 =
	     state_can_overlap &&
	     (jj_repeat_count_read__7_BIT_0_8_AND_NOT_abort__ETC___d78 ||
	      NOT_jj_repeat_count_read__7_BIT_0_8_9_AND_NOT__ETC___d83) ;

  // rule RL_action_ovlp_r_update_l38c9
  assign WILL_FIRE_RL_action_ovlp_r_update_l38c9 =
	     state_can_overlap &&
	     (jj_1_repeat_count_read__8_BIT_0_9_AND_NOT_abor_ETC___d103 ||
	      NOT_jj_1_repeat_count_read__8_BIT_0_9_6_AND_NO_ETC___d106) ;

  // rule RL_fsm_start
  assign WILL_FIRE_RL_fsm_start =
	     abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d123 &&
	     (!start_reg_1 || state_fired) &&
	     start_reg ;

  // rule RL_action_l21c22
  assign WILL_FIRE_RL_action_l21c22 =
	     spiflash_ctrl$RDY_operate &&
	     (start_wire$whas && state_mkFSMstate == 5'd0 ||
	      jj_1_repeat_count[0] && start_wire$whas &&
	      state_mkFSMstate == 5'd18) ;

  // rule RL_action_l32c32
  assign WILL_FIRE_RL_action_l32c32 =
	     spiflash_ctrl$RDY_read_byte &&
	     (jj_repeat_count_read__7_BIT_0_8_AND_NOT_abort__ETC___d78 ||
	      state_mkFSMstate == 5'd10 ||
	      NOT_jj_repeat_count_read__7_BIT_0_8_9_AND_NOT__ETC___d83) ;

  // rule RL_action_l38c32
  assign WILL_FIRE_RL_action_l38c32 =
	     spiflash_ctrl$RDY_read_byte &&
	     (jj_1_repeat_count_read__8_BIT_0_9_AND_NOT_abor_ETC___d103 ||
	      state_mkFSMstate == 5'd17 ||
	      NOT_jj_1_repeat_count_read__8_BIT_0_9_6_AND_NO_ETC___d106) ;

  // rule RL_idle_l20c16
  assign WILL_FIRE_RL_idle_l20c16 =
	     jj_1_repeat_count[0] && !start_wire$whas &&
	     state_mkFSMstate == 5'd18 ;

  // inputs to muxes for submodule ports
  assign MUX_spiflash_ctrl$operate_1__SEL_1 =
	     WILL_FIRE_RL_action_l36c22 || WILL_FIRE_RL_action_l30c22 ;
  assign MUX_spiflash_ctrl$operate_1__SEL_2 =
	     WILL_FIRE_RL_action_l37c22 || WILL_FIRE_RL_action_l31c22 ;
  assign MUX_start_reg$write_1__SEL_2 =
	     abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d130 &&
	     !running ;
  assign MUX_jj_1_repeat_count$write_1__VAL_1 =
	     jj_1_repeat_count[1] ? 2'd1 : x__h53386 ;
  assign MUX_jj_repeat_count$write_1__VAL_1 =
	     jj_repeat_count[1] ? 2'd1 : x__h53196 ;

  // inlined wires
  assign start_wire$whas =
	     WILL_FIRE_RL_fsm_start || start_reg_1 && !state_fired ;
  assign state_set_pw$whas =
	     WILL_FIRE_RL_idle_l20c16 || WILL_FIRE_RL_action_l38c32 ||
	     WILL_FIRE_RL_action_r_init_l38c9 ||
	     WILL_FIRE_RL_action_l37c22 ||
	     WILL_FIRE_RL_action_l36c22 ||
	     WILL_FIRE_RL_action_l34c22 ||
	     WILL_FIRE_RL_action_l32c32 ||
	     WILL_FIRE_RL_action_r_init_l32c9 ||
	     WILL_FIRE_RL_action_l31c22 ||
	     WILL_FIRE_RL_action_l30c22 ||
	     WILL_FIRE_RL_action_l28c22 ||
	     WILL_FIRE_RL_action_l26c22 ||
	     WILL_FIRE_RL_action_l25c22 ||
	     WILL_FIRE_RL_action_l24c22 ||
	     WILL_FIRE_RL_action_l22c22 ||
	     WILL_FIRE_RL_action_l21c22 ;
  assign state_overlap_pw$whas =
	     WILL_FIRE_RL_action_ovlp_r_update_l38c9 ||
	     WILL_FIRE_RL_action_ovlp_r_update_l32c9 ;

  // register jj_1_repeat_count
  assign jj_1_repeat_count$D_IN =
	     WILL_FIRE_RL_action_ovlp_r_update_l38c9 ?
	       MUX_jj_1_repeat_count$write_1__VAL_1 :
	       2'd1 ;
  assign jj_1_repeat_count$EN =
	     WILL_FIRE_RL_action_ovlp_r_update_l38c9 ||
	     WILL_FIRE_RL_action_r_init_l38c9 ;

  // register jj_repeat_count
  assign jj_repeat_count$D_IN =
	     WILL_FIRE_RL_action_ovlp_r_update_l32c9 ?
	       MUX_jj_repeat_count$write_1__VAL_1 :
	       2'd1 ;
  assign jj_repeat_count$EN =
	     WILL_FIRE_RL_action_ovlp_r_update_l32c9 ||
	     WILL_FIRE_RL_action_r_init_l32c9 ;

  // register running
  assign running$D_IN = 1'd1 ;
  assign running$EN = MUX_start_reg$write_1__SEL_2 ;

  // register start_reg
  assign start_reg$D_IN = !WILL_FIRE_RL_fsm_start ;
  assign start_reg$EN =
	     WILL_FIRE_RL_fsm_start ||
	     abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d130 &&
	     !running ;

  // register start_reg_1
  assign start_reg_1$D_IN = start_wire$whas ;
  assign start_reg_1$EN = 1'd1 ;

  // register state_can_overlap
  assign state_can_overlap$D_IN =
	     state_set_pw$whas ||
	     !state_overlap_pw$whas && state_can_overlap ;
  assign state_can_overlap$EN = 1'd1 ;

  // register state_fired
  assign state_fired$D_IN = state_set_pw$whas ;
  assign state_fired$EN = 1'd1 ;

  // register state_mkFSMstate
  always@(WILL_FIRE_RL_idle_l20c16 or
	  WILL_FIRE_RL_action_l21c22 or
	  WILL_FIRE_RL_action_l22c22 or
	  WILL_FIRE_RL_action_l24c22 or
	  WILL_FIRE_RL_action_l25c22 or
	  WILL_FIRE_RL_action_l26c22 or
	  WILL_FIRE_RL_action_l28c22 or
	  WILL_FIRE_RL_action_l30c22 or
	  WILL_FIRE_RL_action_l31c22 or
	  WILL_FIRE_RL_action_r_init_l32c9 or
	  WILL_FIRE_RL_action_l32c32 or
	  WILL_FIRE_RL_action_l34c22 or
	  WILL_FIRE_RL_action_l36c22 or
	  WILL_FIRE_RL_action_l37c22 or
	  WILL_FIRE_RL_action_r_init_l38c9 or WILL_FIRE_RL_action_l38c32)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_idle_l20c16: state_mkFSMstate$D_IN = 5'd0;
      WILL_FIRE_RL_action_l21c22: state_mkFSMstate$D_IN = 5'd1;
      WILL_FIRE_RL_action_l22c22: state_mkFSMstate$D_IN = 5'd2;
      WILL_FIRE_RL_action_l24c22: state_mkFSMstate$D_IN = 5'd3;
      WILL_FIRE_RL_action_l25c22: state_mkFSMstate$D_IN = 5'd4;
      WILL_FIRE_RL_action_l26c22: state_mkFSMstate$D_IN = 5'd5;
      WILL_FIRE_RL_action_l28c22: state_mkFSMstate$D_IN = 5'd6;
      WILL_FIRE_RL_action_l30c22: state_mkFSMstate$D_IN = 5'd7;
      WILL_FIRE_RL_action_l31c22: state_mkFSMstate$D_IN = 5'd8;
      WILL_FIRE_RL_action_r_init_l32c9: state_mkFSMstate$D_IN = 5'd9;
      WILL_FIRE_RL_action_l32c32: state_mkFSMstate$D_IN = 5'd11;
      WILL_FIRE_RL_action_l34c22: state_mkFSMstate$D_IN = 5'd13;
      WILL_FIRE_RL_action_l36c22: state_mkFSMstate$D_IN = 5'd14;
      WILL_FIRE_RL_action_l37c22: state_mkFSMstate$D_IN = 5'd15;
      WILL_FIRE_RL_action_r_init_l38c9: state_mkFSMstate$D_IN = 5'd16;
      WILL_FIRE_RL_action_l38c32: state_mkFSMstate$D_IN = 5'd18;
      default: state_mkFSMstate$D_IN = 5'b01010 /* unspecified value */ ;
    endcase
  end
  assign state_mkFSMstate$EN =
	     WILL_FIRE_RL_idle_l20c16 || WILL_FIRE_RL_action_l21c22 ||
	     WILL_FIRE_RL_action_l22c22 ||
	     WILL_FIRE_RL_action_l24c22 ||
	     WILL_FIRE_RL_action_l25c22 ||
	     WILL_FIRE_RL_action_l26c22 ||
	     WILL_FIRE_RL_action_l28c22 ||
	     WILL_FIRE_RL_action_l30c22 ||
	     WILL_FIRE_RL_action_l31c22 ||
	     WILL_FIRE_RL_action_r_init_l32c9 ||
	     WILL_FIRE_RL_action_l32c32 ||
	     WILL_FIRE_RL_action_l34c22 ||
	     WILL_FIRE_RL_action_l36c22 ||
	     WILL_FIRE_RL_action_l37c22 ||
	     WILL_FIRE_RL_action_r_init_l38c9 ||
	     WILL_FIRE_RL_action_l38c32 ;

  // submodule spiflash_ctrl
  assign spiflash_ctrl$miso_i_i = 1'd0 ;
  always@(MUX_spiflash_ctrl$operate_1__SEL_1 or
	  WILL_FIRE_RL_action_l21c22 or
	  MUX_spiflash_ctrl$operate_1__SEL_2 or
	  WILL_FIRE_RL_action_l22c22 or
	  WILL_FIRE_RL_action_l24c22 or
	  WILL_FIRE_RL_action_l25c22 or
	  WILL_FIRE_RL_action_l28c22 or
	  WILL_FIRE_RL_action_l34c22 or WILL_FIRE_RL_action_l26c22)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_spiflash_ctrl$operate_1__SEL_1 || WILL_FIRE_RL_action_l21c22:
	  spiflash_ctrl$operate_addr = 9'h0;
      MUX_spiflash_ctrl$operate_1__SEL_2 || WILL_FIRE_RL_action_l22c22:
	  spiflash_ctrl$operate_addr = 9'h001;
      WILL_FIRE_RL_action_l24c22: spiflash_ctrl$operate_addr = 9'h100;
      WILL_FIRE_RL_action_l25c22: spiflash_ctrl$operate_addr = 9'h101;
      WILL_FIRE_RL_action_l28c22 || WILL_FIRE_RL_action_l34c22 ||
      WILL_FIRE_RL_action_l26c22:
	  spiflash_ctrl$operate_addr = 9'h108;
      default: spiflash_ctrl$operate_addr =
		   9'b010101010 /* unspecified value */ ;
    endcase
  end
  always@(MUX_spiflash_ctrl$operate_1__SEL_1 or
	  MUX_spiflash_ctrl$operate_1__SEL_2 or
	  WILL_FIRE_RL_action_l25c22 or
	  WILL_FIRE_RL_action_l28c22 or
	  WILL_FIRE_RL_action_l34c22 or
	  WILL_FIRE_RL_action_l21c22 or
	  WILL_FIRE_RL_action_l26c22 or
	  WILL_FIRE_RL_action_l22c22 or WILL_FIRE_RL_action_l24c22)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_spiflash_ctrl$operate_1__SEL_1 ||
      MUX_spiflash_ctrl$operate_1__SEL_2:
	  spiflash_ctrl$operate_data = 8'h0;
      WILL_FIRE_RL_action_l25c22: spiflash_ctrl$operate_data = 8'h01;
      WILL_FIRE_RL_action_l28c22: spiflash_ctrl$operate_data = 8'h02;
      WILL_FIRE_RL_action_l34c22: spiflash_ctrl$operate_data = 8'h03;
      WILL_FIRE_RL_action_l21c22: spiflash_ctrl$operate_data = 8'h12;
      WILL_FIRE_RL_action_l26c22: spiflash_ctrl$operate_data = 8'h20;
      WILL_FIRE_RL_action_l22c22: spiflash_ctrl$operate_data = 8'h34;
      WILL_FIRE_RL_action_l24c22: spiflash_ctrl$operate_data = 8'hAB;
      default: spiflash_ctrl$operate_data =
		   8'b10101010 /* unspecified value */ ;
    endcase
  end
  assign spiflash_ctrl$operate_wr =
	     !MUX_spiflash_ctrl$operate_1__SEL_1 &&
	     !MUX_spiflash_ctrl$operate_1__SEL_2 ;
  assign spiflash_ctrl$EN_operate =
	     WILL_FIRE_RL_action_l36c22 || WILL_FIRE_RL_action_l30c22 ||
	     WILL_FIRE_RL_action_l37c22 ||
	     WILL_FIRE_RL_action_l31c22 ||
	     WILL_FIRE_RL_action_l21c22 ||
	     WILL_FIRE_RL_action_l22c22 ||
	     WILL_FIRE_RL_action_l24c22 ||
	     WILL_FIRE_RL_action_l25c22 ||
	     WILL_FIRE_RL_action_l28c22 ||
	     WILL_FIRE_RL_action_l34c22 ||
	     WILL_FIRE_RL_action_l26c22 ;
  assign spiflash_ctrl$EN_read_byte =
	     WILL_FIRE_RL_action_l38c32 || WILL_FIRE_RL_action_l32c32 ;

  // remaining internal signals
  assign NOT_jj_1_repeat_count_read__8_BIT_0_9_6_AND_NO_ETC___d106 =
	     !jj_1_repeat_count[0] && state_mkFSMstate == 5'd18 ;
  assign NOT_jj_repeat_count_read__7_BIT_0_8_9_AND_NOT__ETC___d83 =
	     !jj_repeat_count[0] && state_mkFSMstate == 5'd11 ;
  assign abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d123 =
	     state_mkFSMstate == 5'd0 ||
	     jj_1_repeat_count[0] && state_mkFSMstate == 5'd18 ;
  assign abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d130 =
	     abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d123 &&
	     (!start_reg_1 || state_fired) &&
	     !start_reg ;
  assign jj_1_repeat_count_read__8_BIT_0_9_AND_NOT_abor_ETC___d103 =
	     jj_1_repeat_count[0] && state_mkFSMstate == 5'd15 ||
	     state_mkFSMstate == 5'd16 ;
  assign jj_repeat_count_read__7_BIT_0_8_AND_NOT_abort__ETC___d78 =
	     jj_repeat_count[0] && state_mkFSMstate == 5'd8 ||
	     state_mkFSMstate == 5'd9 ;
  assign x__h53196 = { jj_repeat_count[0], 1'd0 } ;
  assign x__h53386 = { jj_1_repeat_count[0], 1'd0 } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        jj_1_repeat_count <= `BSV_ASSIGNMENT_DELAY 2'd1;
	jj_repeat_count <= `BSV_ASSIGNMENT_DELAY 2'd1;
	running <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 5'd0;
      end
    else
      begin
        if (jj_1_repeat_count$EN)
	  jj_1_repeat_count <= `BSV_ASSIGNMENT_DELAY jj_1_repeat_count$D_IN;
	if (jj_repeat_count$EN)
	  jj_repeat_count <= `BSV_ASSIGNMENT_DELAY jj_repeat_count$D_IN;
	if (running$EN) running <= `BSV_ASSIGNMENT_DELAY running$D_IN;
	if (start_reg$EN) start_reg <= `BSV_ASSIGNMENT_DELAY start_reg$D_IN;
	if (start_reg_1$EN)
	  start_reg_1 <= `BSV_ASSIGNMENT_DELAY start_reg_1$D_IN;
	if (state_can_overlap$EN)
	  state_can_overlap <= `BSV_ASSIGNMENT_DELAY state_can_overlap$D_IN;
	if (state_fired$EN)
	  state_fired <= `BSV_ASSIGNMENT_DELAY state_fired$D_IN;
	if (state_mkFSMstate$EN)
	  state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY state_mkFSMstate$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    jj_1_repeat_count = 2'h2;
    jj_repeat_count = 2'h2;
    running = 1'h0;
    start_reg = 1'h0;
    start_reg_1 = 1'h0;
    state_can_overlap = 1'h0;
    state_fired = 1'h0;
    state_mkFSMstate = 5'h0A;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l32c32)
	$display("read_byte = %x", spiflash_ctrl$read_byte);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l38c32)
	$display("read_byte = %x", spiflash_ctrl$read_byte);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l21c22 &&
	  (WILL_FIRE_RL_action_l22c22 || WILL_FIRE_RL_action_l24c22 ||
	   WILL_FIRE_RL_action_l25c22 ||
	   WILL_FIRE_RL_action_l26c22 ||
	   WILL_FIRE_RL_action_l28c22 ||
	   WILL_FIRE_RL_action_l30c22 ||
	   WILL_FIRE_RL_action_l31c22 ||
	   WILL_FIRE_RL_action_r_init_l32c9 ||
	   WILL_FIRE_RL_action_l32c32 ||
	   WILL_FIRE_RL_action_l34c22 ||
	   WILL_FIRE_RL_action_l36c22 ||
	   WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 21, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l21c22] and\n  [RL_action_l22c22, RL_action_l24c22, RL_action_l25c22, RL_action_l26c22,\n  RL_action_l28c22, RL_action_l30c22, RL_action_l31c22,\n  RL_action_r_init_l32c9, RL_action_l32c32, RL_action_l34c22,\n  RL_action_l36c22, RL_action_l37c22, RL_action_r_init_l38c9,\n  RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l22c22 &&
	  (WILL_FIRE_RL_action_l24c22 || WILL_FIRE_RL_action_l25c22 ||
	   WILL_FIRE_RL_action_l26c22 ||
	   WILL_FIRE_RL_action_l28c22 ||
	   WILL_FIRE_RL_action_l30c22 ||
	   WILL_FIRE_RL_action_l31c22 ||
	   WILL_FIRE_RL_action_r_init_l32c9 ||
	   WILL_FIRE_RL_action_l32c32 ||
	   WILL_FIRE_RL_action_l34c22 ||
	   WILL_FIRE_RL_action_l36c22 ||
	   WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 22, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l22c22] and\n  [RL_action_l24c22, RL_action_l25c22, RL_action_l26c22, RL_action_l28c22,\n  RL_action_l30c22, RL_action_l31c22, RL_action_r_init_l32c9,\n  RL_action_l32c32, RL_action_l34c22, RL_action_l36c22, RL_action_l37c22,\n  RL_action_r_init_l38c9, RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l24c22 &&
	  (WILL_FIRE_RL_action_l25c22 || WILL_FIRE_RL_action_l26c22 ||
	   WILL_FIRE_RL_action_l28c22 ||
	   WILL_FIRE_RL_action_l30c22 ||
	   WILL_FIRE_RL_action_l31c22 ||
	   WILL_FIRE_RL_action_r_init_l32c9 ||
	   WILL_FIRE_RL_action_l32c32 ||
	   WILL_FIRE_RL_action_l34c22 ||
	   WILL_FIRE_RL_action_l36c22 ||
	   WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 24, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l24c22] and\n  [RL_action_l25c22, RL_action_l26c22, RL_action_l28c22, RL_action_l30c22,\n  RL_action_l31c22, RL_action_r_init_l32c9, RL_action_l32c32,\n  RL_action_l34c22, RL_action_l36c22, RL_action_l37c22,\n  RL_action_r_init_l38c9, RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l25c22 &&
	  (WILL_FIRE_RL_action_l26c22 || WILL_FIRE_RL_action_l28c22 ||
	   WILL_FIRE_RL_action_l30c22 ||
	   WILL_FIRE_RL_action_l31c22 ||
	   WILL_FIRE_RL_action_r_init_l32c9 ||
	   WILL_FIRE_RL_action_l32c32 ||
	   WILL_FIRE_RL_action_l34c22 ||
	   WILL_FIRE_RL_action_l36c22 ||
	   WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 25, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l25c22] and\n  [RL_action_l26c22, RL_action_l28c22, RL_action_l30c22, RL_action_l31c22,\n  RL_action_r_init_l32c9, RL_action_l32c32, RL_action_l34c22,\n  RL_action_l36c22, RL_action_l37c22, RL_action_r_init_l38c9,\n  RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l26c22 &&
	  (WILL_FIRE_RL_action_l28c22 || WILL_FIRE_RL_action_l30c22 ||
	   WILL_FIRE_RL_action_l31c22 ||
	   WILL_FIRE_RL_action_r_init_l32c9 ||
	   WILL_FIRE_RL_action_l32c32 ||
	   WILL_FIRE_RL_action_l34c22 ||
	   WILL_FIRE_RL_action_l36c22 ||
	   WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 26, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l26c22] and\n  [RL_action_l28c22, RL_action_l30c22, RL_action_l31c22,\n  RL_action_r_init_l32c9, RL_action_l32c32, RL_action_l34c22,\n  RL_action_l36c22, RL_action_l37c22, RL_action_r_init_l38c9,\n  RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l28c22 &&
	  (WILL_FIRE_RL_action_l30c22 || WILL_FIRE_RL_action_l31c22 ||
	   WILL_FIRE_RL_action_r_init_l32c9 ||
	   WILL_FIRE_RL_action_l32c32 ||
	   WILL_FIRE_RL_action_l34c22 ||
	   WILL_FIRE_RL_action_l36c22 ||
	   WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 28, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l28c22] and\n  [RL_action_l30c22, RL_action_l31c22, RL_action_r_init_l32c9,\n  RL_action_l32c32, RL_action_l34c22, RL_action_l36c22, RL_action_l37c22,\n  RL_action_r_init_l38c9, RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l30c22 &&
	  (WILL_FIRE_RL_action_l31c22 || WILL_FIRE_RL_action_r_init_l32c9 ||
	   WILL_FIRE_RL_action_l32c32 ||
	   WILL_FIRE_RL_action_l34c22 ||
	   WILL_FIRE_RL_action_l36c22 ||
	   WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 30, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l30c22] and\n  [RL_action_l31c22, RL_action_r_init_l32c9, RL_action_l32c32,\n  RL_action_l34c22, RL_action_l36c22, RL_action_l37c22,\n  RL_action_r_init_l38c9, RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l31c22 &&
	  (WILL_FIRE_RL_action_r_init_l32c9 || WILL_FIRE_RL_action_l32c32 ||
	   WILL_FIRE_RL_action_l34c22 ||
	   WILL_FIRE_RL_action_l36c22 ||
	   WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 31, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l31c22] and\n  [RL_action_r_init_l32c9, RL_action_l32c32, RL_action_l34c22,\n  RL_action_l36c22, RL_action_l37c22, RL_action_r_init_l38c9,\n  RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l32c32 &&
	  (WILL_FIRE_RL_action_l34c22 || WILL_FIRE_RL_action_l36c22 ||
	   WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 32, column 32: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l32c32] and\n  [RL_action_l34c22, RL_action_l36c22, RL_action_l37c22,\n  RL_action_r_init_l38c9, RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_r_init_l32c9 &&
	  (WILL_FIRE_RL_action_l32c32 || WILL_FIRE_RL_action_l34c22 ||
	   WILL_FIRE_RL_action_l36c22 ||
	   WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 32, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_r_init_l32c9] and\n  [RL_action_l32c32, RL_action_l34c22, RL_action_l36c22, RL_action_l37c22,\n  RL_action_r_init_l38c9, RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l34c22 &&
	  (WILL_FIRE_RL_action_l36c22 || WILL_FIRE_RL_action_l37c22 ||
	   WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 34, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l34c22] and\n  [RL_action_l36c22, RL_action_l37c22, RL_action_r_init_l38c9,\n  RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l36c22 &&
	  (WILL_FIRE_RL_action_l37c22 || WILL_FIRE_RL_action_r_init_l38c9 ||
	   WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 36, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l36c22] and\n  [RL_action_l37c22, RL_action_r_init_l38c9, RL_action_l38c32] ) fired in the\n  same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l37c22 &&
	  (WILL_FIRE_RL_action_r_init_l38c9 || WILL_FIRE_RL_action_l38c32))
	$display("Error: \"TbSPIFlashController.bsv\", line 37, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l37c22] and\n  [RL_action_r_init_l38c9, RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_r_init_l38c9 && WILL_FIRE_RL_action_l38c32)
	$display("Error: \"TbSPIFlashController.bsv\", line 38, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_r_init_l38c9] and\n  [RL_action_l38c32] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (running &&
	  abort_whas_AND_abort_wget_OR_state_mkFSMstate__ETC___d130)
	$finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkTb

